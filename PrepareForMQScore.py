"""
PrepareForMQScore.py

This program prepares the input of multiple programs for TrainMQScore.  It assumes
that each program has already been converted to quasi-inspect format, meaning that
the annotation and scan and filename are in the correct column.  It does not have
to contain the correct features or MQScore, those will be generated by this program.
"""

UsageInfo = """
PrepareForMQScore.py

This program prepares the input of multiple programs for TrainMQScore.
Required Options
 -r [Directory] Directory containing the output of other programs
     like SEQUEST or Mascot (partially formated for Inspect)
 -i [Directory] Directory of Raw Inspect results
 -m [Directory] Directory of .mzxml or .mgf files
 -s [Directory] Directory for the sorted merged results

"""

import os
import sys
import getopt
import traceback
import ResultsParser
import PyInspect
from Utils import *

Initialize()

class PrepareClass(ResultsParser.ResultsParser):
    def __init__(self):
        self.RawInspectDir = None
        self.OtherProgramsDir = None
        self.NewRawInspectDir = "MergedRawInspectResults"
        self.SortedDir = "Sorted"
        self.OtherProgramResults = {} #(File,scan)=> [(Bits), ..]
        self.MZXMLDir = None
        ResultsParser.ResultsParser.__init__(self)
        
    def Main(self):
        MakeDirectory(self.NewRawInspectDir)
        MakeDirectory(self.SortedDir)
        # read outputs from other programs
        self.ProcessResultsFiles(self.OtherProgramsDir, self.ReadOtherPrograms)
        # merge outputs from other programs with those of Inspect
        self.ProcessResultsFiles(self.RawInspectDir, self.MergeResults)
        # rank merged results by score and compute delta scores
        self.ProcessResultsFiles(self.NewRawInspectDir, self.RankMergedResults)
        os.rmdir(self.NewRawInspectDir)

    def MergeResults(self, FilePath):
        """this is for a single raw inspect file.  We check to
        see if the Other programs have an annotation for this
        spectrum that differs from our top result.  If so, then we
        write it in where it belongs.
        """
        print "MergeResults: %s" %FilePath
        OldInspectHandle = open (FilePath, "rb")
        FileName = os.path.split(FilePath)[1]
        NewPath = os.path.join(self.NewRawInspectDir, FileName)
        NewInspectHandle = open (NewPath, "wb")
        FirstLine = 0
        OldSpectrum = None
        for Line in OldInspectHandle.xreadlines():
            if Line[0] == "#": #comments
                NewInspectHandle.write(Line)
                continue
            Bits = list(Line.split("\t"))
            try:
                FilePath = Bits[0]
                FileName = os.path.split(FilePath)[1]
                Spectrum = (FileName, Bits[1])  # just a name, not the full path
                Bits[0] = FileName          # simplify file path to just file name
                Line = "\t".join(Bits)
            except:
                traceback.print_exc()
                print Bits
                continue
            if Spectrum == OldSpectrum:
                #lower results for Inspect, just print off.  nothing exciting here
                NewInspectHandle.write(Line)
                continue
            ## Here we are at the first line of the old Inspect results.  THis is the meat of the function
            OldSpectrum = Spectrum
            NewInspectHandle.write(Line)
            
            if not self.OtherProgramResults.has_key(Spectrum):
                continue
            
            ## Get scores for the new Annotations
            NewAnnotationLines = []
            for Bits in self.OtherProgramResults[Spectrum]:
                NewLine = self.FormatScoresForAnnotation(Spectrum, Bits)
                NewInspectHandle.write(NewLine)

            ##somewhere down here we have to remove the entry from self.OtherProgramResults
            ## so that we can in the end cycle through all the unique ones.
            if self.OtherProgramResults.has_key(Spectrum):
                del self.OtherProgramResults[Spectrum]

        OldInspectHandle.close()
        NewInspectHandle.close()

    def FormatScoresForAnnotation(self, Spectrum, Bits):
        """ Reminder
        SpectrumFile = 0, ScanNumber = 1, Annotation = 2, ProteinName = 3,Charge = 4
        MQScore = 5, Length = 6, TotalPRMScore = 7, MedianPRMScore = 8, FractionY = 9
        FractionB = 10, Intensity = 11, NTT = 12,
        PValue = 13, FScore = 14, DeltaScoreAny = 15
        DeltaScore = 16
        ProteinID = 17
        DBPos = 18
        FileOffset = 19   
        """
        print "FormatScoresForAnnotation..."
        print Spectrum
        SpectrumFile = os.path.join(self.MZXMLDir, Spectrum[0])
        ScanNum = int(Spectrum[1])
        Annotation = Bits[self.Columns.Annotation]
        Protein = Bits[self.Columns.ProteinName]
        Charge = int(Bits[self.Columns.Charge])
        SpectrumFilePos = int(Bits[self.Columns.FileOffset])
        ReturnLine = "%s\t%s\t%s\t%s\t%s\t"%(Spectrum[0], ScanNum, Annotation, Protein, Charge)
        ## load the spectrum and model and get the score and features
        
        # check for error in byte offset
        File = open(SpectrumFile, "rb")
        File.seek(SpectrumFilePos)
        Text = File.read(300)
        Place = Text.find("BEGIN")
        if not Text.find("BEGIN") == 0:
            print "**error**"
        File.close()
        
        print "PyInspect.Spectrum: %s, %s"%(SpectrumFile, SpectrumFilePos)
        PySpectrum = PyInspect.Spectrum(SpectrumFile, SpectrumFilePos)
        Peptide = GetPeptideFromModdedName(Annotation)
        ParentMass = Peptide.GetParentMass()
        self.LoadModel(Charge, Annotation, "QTOF")
        PySpectrum.SetParentMass(ParentMass, Charge)
        PySpectrum.PrepareIonScoring(1)
        Features = PySpectrum.ScorePeptideDetailed(Annotation, Charge)
                
        ## add MQscore through NTTSpectrum (5-12)
        for Feature in Features:
            ReturnLine += "%s\t"%Feature

        ReturnLine += "Dummy\tDummy\tDummy\tDummy\tDummy\tDummy\t%s\n"%SpectrumFilePos
        return ReturnLine
        ## don't know pvalue or Fscore
            
    def LoadModel(self, Charge, Annotation, InstrumentType):
        """ Must load a model into PyInspect, otherwise there
        will be no peak labeling
        """
        if Annotation.find("phos") > 0:
            if Charge < 3:
                PyInspect.LoadBNModel("PhosCut2.bn")
            else: 
                PyInspect.LoadBNModel("PhosCut3.bn")
        elif InstrumentType == "QTOF":
            if Charge < 3:
                PyInspect.LoadBNModel("QTag2.bn")
            else: 
                PyInspect.LoadBNModel("QTag3.bn")
        else:            
            if Charge < 3:
                PyInspect.LoadBNModel("Tag2.bn")
            else: 
                PyInspect.LoadBNModel("Tag3.bn")
        

    def ReadOtherPrograms(self, FilePath):
        """Here we take the output of other programs
        and put them into a dictionary so that we can
        at a later time score and merge them
        """
        print "ReadOtherPrograms: %s" %FilePath
        Handle = open(FilePath, "rb")
        for Line in Handle.xreadlines():
            if Line[0] == "#":
                continue
            Bits = list(Line.split("\t"))
            try:
                FilePath = Bits[0]
                FileName = os.path.split(FilePath)[1]
                Spectrum = (FileName, Bits[1])  # just a name, not the full path
            except:
                traceback.print_exc()
                print Bits
                continue
            if not self.OtherProgramResults.has_key(Spectrum):
                self.OtherProgramResults[Spectrum] = []
            self.OtherProgramResults[Spectrum].append(tuple(Bits))
        Handle.close()

    def RankMergedResults(self, FilePath):
        """
        Rank merged results by score
        Compute delta score for each entry 
        """
        print "RankMergedResults: %s" %FilePath

        ReadHandle = open(FilePath, "rb")
        FileName = os.path.split(FilePath)[1]
        NewPath = os.path.join(self.SortedDir, FileName)
        WriteHandle = open(NewPath, "wb")

        Entries = {}    # key = score, value = entry tab-delimited string
        LastScan = -1
        End = 0
        # get end of file position
        ReadHandle.seek(0,2)
        EndPosition = ReadHandle.tell()
        ReadHandle.seek(0)
        print "EndPos = %s"%EndPosition
        CurrentPosition = 0
        
        while CurrentPosition < EndPosition:
            Line = ReadHandle.readline()
            CurrentPosition = ReadHandle.tell()

            if CurrentPosition == EndPosition:  # last line
                End = 1
            elif Line[0] == "#":
                continue
            
            Bits = list(Line.split("\t"))
            Scan = Bits[self.Columns.ScanNumber]
            Score = float(Bits[self.Columns.MQScore])
            if Scan != LastScan or End == 1:   # entries for a new scan or last entry
                if Entries == {}:    # first entry
                    Entries[Score] = Line    # just add
                else:
                    if End == 1:
                        print "scan #: %s, pos: %s" %(Scan, CurrentPosition)
                        
                    if End == 1 and Scan == LastScan:    # last entry of the current scan
                        Entries[Score] = Line
                        
                    # sort and write to output file
                    Keys = Entries.keys()
                    Keys.sort()
                    Keys.reverse()
                    TopScore = Keys[0]   # top score of current scan
                    TopEntry = list(Entries[TopScore].split("\t"))
                    TopAnnotation = TopEntry[self.Columns.Annotation]
                    # find the next best entry (with annotation different from the top entry)
                    Found = 0
                    Index = 1
                    while Found == 0 and Index < len(Keys):
                        NextEntry = list(Entries[Keys[Index]].split("\t"))
                        NextAnnotation = NextEntry[self.Columns.Annotation]
                        if TopAnnotation != NextAnnotation:
                            Found = 1
                            NextScore = Keys[Index]
                        else:
                            Index = Index + 1

                    if Found == 0:  # only one annotation for this scan number
                        # add all the entries (DeltaScore = 0)
                        for Key in Keys:
                            Entry = list(Entries[Key].split("\t"))
                            Entry[self.Columns.DeltaScore] = "0"
                            Entry[self.Columns.DeltaScoreAny] = "0"
                            WriteHandle.write("\t".join(Entry))
                    else:   # found next best entry
                        DeltaScore = str(TopScore - NextScore)       # top entry
                        TopEntry[self.Columns.DeltaScore] = DeltaScore
                        TopEntry[self.Columns.DeltaScoreAny] = DeltaScore
                        WriteHandle.write("\t".join(TopEntry))
                        # compute delta scores for and write other entries
                        for I in range(1, Index):   # annotation same as top entry
                            Entry = list(Entries[Keys[I]].split("\t"))
                            Entry[self.Columns.DeltaScore] = DeltaScore
                            Entry[self.Columns.DeltaScoreAny] = DeltaScore
                            WriteHandle.write("\t".join(Entry))
                        for I in range(Index, len(Keys)):   # annotation different from top entry
                            Entry = list(Entries[Keys[I]].split("\t"))
                            DeltaScore = str(Keys[I] - TopScore)
                            Entry[self.Columns.DeltaScore] = DeltaScore
                            Entry[self.Columns.DeltaScoreAny] = DeltaScore
                            WriteHandle.write("\t".join(Entry))

                    if End == 1 and Scan != LastScan:    # last entry is a new scan
                        Entry = list(Line.split("\t"))
                        Entry[self.Columns.DeltaScore] = "0"
                        Entry[self.Columns.DeltaScoreAny] = "0"
                        WriteHandle.write("\t".join(Entry))                        
                    if End == 1:
                        break
                    else:
                        Entries = {}    # clear dictionary
                        Entries[Score] = Line   # add new entry
                LastScan = Scan        
            else:   # entries for the current scan being examined
                Entries[Score] = Line        # just add

        ReadHandle.close()
        WriteHandle.close()
        os.remove(FilePath)
        
    def ParseCommandLine(self,Arguments):
        (Options, Args) = getopt.getopt(Arguments, "r:i:m:s:")
        OptionsSeen = {}
        for (Option, Value) in Options:
            OptionsSeen[Option] = 1
            if Option == "-r":
                # -r results file(s)
                if not os.path.exists(Value):
                    print "** Error: couldn't find results file '%s'\n\n"%Value
                    print UsageInfo
                    sys.exit(1)
                self.OtherProgramsDir = Value
            if Option == "-i":
                self.RawInspectDir = Value
            if Option == "-m":
                self.MZXMLDir = Value
            if Option == "-s":
                self.SortedDir = Value
        if not OptionsSeen.has_key("-r") or not OptionsSeen.has_key("-i") or not OptionsSeen.has_key("-m") or not OptionsSeen.has_key("-s"):
            print UsageInfo
            sys.exit(1)


if __name__ == "__main__":
    try:
        import psyco
        psyco.full()
    except:
        print "(psyco not found - running in non-optimized mode)"
    BoyScout = PrepareClass()
    BoyScout.ParseCommandLine(sys.argv[1:])
    BoyScout.Main()

